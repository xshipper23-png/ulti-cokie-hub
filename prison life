local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "prison life",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "g", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local combatTab = Window:CreateTab("combat", nil) -- Title, Image
local PLTab = Window:CreateTab("player", nil) -- Title, Image
local tpTab = Window:CreateTab("teleport", nil) -- Title, Image
local stuffTab = Window:CreateTab("other stuff", nil) -- Title, Image
local gTab = Window:CreateTab("give", nil) -- Title, Image

local Toggle = PLTab:CreateToggle({
   Name = "INFINIT JUMP",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(infijump)
-- GLOBAL BOOLEAN zur Steuerung
if _G.InfiniteJumpEnabled == nil then
    _G.InfiniteJumpEnabled = true -- erstes Mal starten ‚Üí aktiv
else
    _G.InfiniteJumpEnabled = not _G.InfiniteJumpEnabled -- beim erneuten Starten ‚Üí Toggle
end

print("[DEBUG] Infinite Jump Status:", _G.InfiniteJumpEnabled)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- Verbindung, die nur einmal erstellt wird
if not _G._InfiniteJumpConnection then
    _G._InfiniteJumpConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Space and _G.InfiniteJumpEnabled then
            local character = player.Character
            if not character then return end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "AIMBOT",
   CurrentValue = false,
   Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
  -- Aimbot Toggle Script
-- LocalScript (StarterPlayerScripts)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Toggle: beim ersten Start true, beim erneuten Start umkehren
if _G.AimBotEnabled == nil then
    _G.AimBotEnabled = true
else
    _G.AimBotEnabled = not _G.AimBotEnabled
end

print("[AIMBOT] Status:", _G.AimBotEnabled and "ON" or "OFF")

-- Einstellungen (kannst du anpassen)
local MAX_DISTANCE = 300      -- maximale Zielentfernung
local FOV_DEGREES = 80        -- Sichtfeld (gr√∂√üer = mehr Ziele)
local SMOOTHING = 0.35        -- 0 = instant, 1 = keine Bewegung (0..1), z.B. 0.35 = weich
local AIM_PART = "Head"       -- Zielteil am Gegner (z. B. "Head" oder "UpperTorso")

-- Hilfsfunktion: findet bestes Ziel
local function findBestTarget()
    if not camera or not localPlayer.Character then return nil end
    local camPos = camera.CFrame.Position
    local bestPlayer, bestPart, bestScore = nil, nil, -1
    local fovCos = math.cos(math.rad(FOV_DEGREES))

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character and pl.Character.Parent then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local part = pl.Character:FindFirstChild(AIM_PART) or pl.Character:FindFirstChild("HumanoidRootPart")
                if part and part:IsA("BasePart") then
                    local dir = (part.Position - camPos)
                    local dist = dir.Magnitude
                    if dist <= MAX_DISTANCE then
                        local dirUnit = dir.Unit
                        local forward = camera.CFrame.LookVector
                        local dot = forward:Dot(dirUnit)
                        if dot > fovCos then
                            -- Score kann Kombination aus dot (Ausrichtung) und inverse Distanz sein
                            local score = dot - (dist / (MAX_DISTANCE*2))
                            if score > bestScore then
                                bestScore = score
                                bestPlayer = pl
                                bestPart = part
                            end
                        end
                    end
                end
            end
        end
    end

    return bestPlayer, bestPart
end

-- Verbindung managen
if _G._AimBotConnection then
    -- Falls schon eine Verbindung existiert (aus vorherigem Lauf), trennen wir sie zuerst
    pcall(function() _G._AimBotConnection:Disconnect() end)
    _G._AimBotConnection = nil
end

if _G.AimBotEnabled then
    _G._AimBotConnection = RunService.RenderStepped:Connect(function()
        -- Sicherheitschecks
        if not camera then camera = workspace.CurrentCamera; if not camera then return end end
        if not localPlayer or not localPlayer.Character then return end

        local _, targetPart = findBestTarget()
        if targetPart then
            local camPos = camera.CFrame.Position
            local targetPos = targetPart.Position
            -- berechne gew√ºnschtes CFrame, das von Kamera-Position auf target schaut
            local desiredCFrame = CFrame.new(camPos, targetPos)
            -- Smooth Lerp der Kamera-Rotation (Position bleibt gleich)
            camera.CFrame = camera.CFrame:Lerp(desiredCFrame, SMOOTHING)
        end
    end)
else
    print("[AIMBOT] Deactivated, no connection left.")
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "ESP name ",
   CurrentValue = false,
   Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
--// Full Client ESP (Highlight + Name + Health)
-- f√ºhrt bei erneutem Ausf√ºhren Toggle aus

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Check, ob bereits ESP l√§uft
if _G.FullESP_Active then
	-- üî¥ Wenn Script schon l√§uft ‚Üí ausschalten
	print("[ESP] Deaktiviert")
	_G.FullESP_Active = false

	for _, hl in pairs(workspace:GetDescendants()) do
		if hl:IsA("Highlight") and hl.Name == "ClientESP" then
			hl:Destroy()
		end
	end
	for _, plr in pairs(Players:GetPlayers()) do
		if plr.Character then
			local head = plr.Character:FindFirstChild("Head")
			if head then
				local gui = head:FindFirstChild("NameHealthESP")
				if gui then gui:Destroy() end
			end
		end
	end
	return
end

-- üü¢ Wenn ESP noch nicht aktiv ist ‚Üí einschalten
_G.FullESP_Active = true
print("[ESP] Aktiviert")

local Highlights = {}
local Billboards = {}

-- === Hilfsfunktionen ===

local function createBillboard(player)
	if player == LocalPlayer then return end
	if not player.Character then return end
	local head = player.Character:FindFirstChild("Head")
	if not head then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameHealthESP"
	billboard.AlwaysOnTop = true
	billboard.Size = UDim2.new(4, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.MaxDistance = 500
	billboard.Parent = head

	-- Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.BackgroundTransparency = 1
	nameLabel.Size = UDim2.new(1, 0, 0.4, 0)
	nameLabel.Text = player.DisplayName
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextScaled = true
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.Parent = billboard

	-- Health Bar Hintergrund
	local bg = Instance.new("Frame")
	bg.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	bg.BorderSizePixel = 0
	bg.Position = UDim2.new(0.1, 0, 0.5, 0)
	bg.Size = UDim2.new(0.8, 0, 0.2, 0)
	bg.Parent = billboard

	-- Health Bar F√ºllung
	local fill = Instance.new("Frame")
	fill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
	fill.BorderSizePixel = 0
	fill.Size = UDim2.new(1, 0, 1, 0)
	fill.Parent = bg

	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		local function updateHealth()
			local ratio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
			fill.Size = UDim2.new(ratio, 0, 1, 0)
			if ratio > 0.5 then
				fill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
			elseif ratio > 0.25 then
				fill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
			else
				fill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
			end
		end
		humanoid.HealthChanged:Connect(updateHealth)
		updateHealth()
	end

	Billboards[player] = billboard
end

local function createHighlight(player)
	if player == LocalPlayer then return end
	if not player.Character then return end

	local hl = Instance.new("Highlight")
	hl.Name = "ClientESP"
	hl.Adornee = player.Character
	hl.FillColor = Color3.fromRGB(255, 0, 0)
	hl.FillTransparency = 0.6
	hl.OutlineColor = Color3.fromRGB(255, 255, 255)
	hl.OutlineTransparency = 0.1
	hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	hl.Parent = player.Character

	Highlights[player] = hl
	createBillboard(player)

	local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.Died:Connect(function()
			if hl and hl.Parent then
				local clone = hl:Clone()
				clone.Parent = workspace
				clone.Adornee = player.Character
				task.delay(8, function()
					if clone then clone:Destroy() end
				end)
			end
			Highlights[player] = nil
		end)
	end
end

-- === Haupt-Setup ===

for _, plr in pairs(Players:GetPlayers()) do
	if plr ~= LocalPlayer then
		createHighlight(plr)
	end
	plr.CharacterAdded:Connect(function()
		task.wait(0.2)
		if _G.FullESP_Active then
			createHighlight(plr)
		end
	end)
end

Players.PlayerAdded:Connect(function(plr)
	if _G.FullESP_Active then
		plr.CharacterAdded:Connect(function()
			task.wait(0.2)
			createHighlight(plr)
		end)
	end
end)

Players.PlayerRemoving:Connect(function(plr)
	if Highlights[plr] then
		Highlights[plr]:Destroy()
		Highlights[plr] = nil
	end
	local head = plr.Character and plr.Character:FindFirstChild("Head")
	if head then
		local gui = head:FindFirstChild("NameHealthESP")
		if gui then gui:Destroy() end
	end
end)

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "speed",
   Range = {10, 300},
   Increment = 1,
   Suffix = " ",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(speed)
-- Optimiertes Live-Speed Script (kein Spam)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastSpeed -- merkt sich den alten Wert

-- Funktion: liest aktuellen speed-Wert
local function getSpeed()
    if typeof(speed) == "function" then
        return speed()
    elseif typeof(speed) == "Instance" and speed:IsA("NumberValue") then
        return speed.Value
    else
        return speed
    end
end

-- Funktion: setzt Geschwindigkeit nur wenn n√∂tig
local function applySpeed()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newSpeed = getSpeed()
    if newSpeed ~= lastSpeed then
        humanoid.WalkSpeed = newSpeed
        print("[SPEED] WalkSpeed ge√§ndert auf:", newSpeed)
        lastSpeed = newSpeed
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastSpeed = nil
    applySpeed()
end)

-- Wenn speed ein NumberValue ist ‚Üí live zuh√∂ren
if typeof(speed) == "Instance" and speed:IsA("NumberValue") then
    speed:GetPropertyChangedSignal("Value"):Connect(function()
        applySpeed()
    end)
end

-- Nur ca. 5x pro Sekunde pr√ºfen (schont CPU)
RunService.Stepped:Connect(function(_, step)
    applySpeed()
end)

-- Anfang
applySpeed()

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "jump BOST",
   Range = {0, 250},
   Increment = 10,
   Suffix = " ",
   CurrentValue = 25,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(jumpb)
  -- Optimiertes Live-Jump Script (Variable/Funktion/NumberValue "jumpb")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastJump -- merkt sich den alten Wert

-- Funktion: liest aktuellen jumpb-Wert
local function getJump()
    if typeof(jumpb) == "function" then
        return jumpb()
    elseif typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
        return jumpb.Value
    else
        return jumpb
    end
end

-- Funktion: setzt JumpPower nur wenn n√∂tig
local function applyJump()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newJump = getJump()
    if newJump ~= lastJump then
        humanoid.UseJumpPower = true -- sicherstellen, dass JumpPower benutzt wird
        humanoid.JumpPower = newJump
        print("[JUMP] JumpPower ge√§ndert auf:", newJump)
        lastJump = newJump
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastJump = nil
    applyJump()
end)

-- Wenn jumpb ein NumberValue ist ‚Üí live zuh√∂ren
if typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
    jumpb:GetPropertyChangedSignal("Value"):Connect(function()
        applyJump()
    end)
end

-- Alle paar Frames pr√ºfen (nicht spammen)
RunService.Stepped:Connect(function()
    applyJump()
end)

-- Anfang
applyJump()

   end,
})

local Section = gTab:CreateSection("give weopens")

local Button = gTab:CreateButton({
   Name = "get pistol",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(814, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = gTab:CreateButton({
   Name = "get pump",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(821, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = gTab:CreateButton({
   Name = "get AK-47",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-922, 94, 2051) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Section = tpTab:CreateSection("in prison tps")

local Button = tpTab:CreateButton({
   Name = "roof",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(915, 150, 2286) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "weopen room police",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(848, 103, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Section = tpTab:CreateSection("open world tps ")

local Button = tpTab:CreateButton({
   Name = "prison front",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(484, 100, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "on prison wall",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(1050, 125, 2561) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "crim base",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-863, 98, 2108) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Toggle = PLTab:CreateToggle({
   Name = "NOCLIP",
   CurrentValue = false,
   Flag = "Togglefnopeclip", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
-- Noclip Script (Toggle on run)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local RunService = game:GetService("RunService")

-- Shared toggle state (global)
_G.noclip = not _G.noclip

if _G.noclip then
    print("Noclip ON")
    _G.noclipConnection = RunService.Stepped:Connect(function()
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
else
    print("Noclip OFF")
    if _G.noclipConnection then
        _G.noclipConnection:Disconnect()
        _G.noclipConnection = nil
    end
    -- Reset collisions
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "delet all doors(only client)",
   Callback = function()
   -- LocalScript: l√∂scht lokal alle Kinder eines Ordners namens "Doors" im Workspace
local RunService = game:GetService("RunService")

-- diese Abfrage stellt sicher, dass es CLIENT-SEITIG ist (LocalScript)
if not RunService:IsClient() then
    warn("Dieses Script ist f√ºr den Client gedacht.")
    return
end

local folder = workspace:FindFirstChild("Doors")
if not folder then
    warn("Ordner 'Doors' nicht gefunden im Workspace.")
    return
end

-- Sicherer L√∂schversuch
local success, err = pcall(function()
    -- ClearAllChildren l√∂scht alle Children; alternativ for-loop, wenn du mehr Kontrolle willst.
    folder:ClearAllChildren()
end)

if success then
    print("Alle Kinder von 'Doors' lokal entfernt.")
else
    warn("Fehler beim Entfernen: " .. tostring(err))
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "anti taser ()",
   Callback = function()
   -- LocalScript: Setzt WalkSpeed auf 50, wenn er auf 0 f√§llt
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function monitorWalkSpeed()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	print("üëü WalkSpeed-Monitor gestartet.")

	humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if humanoid.WalkSpeed == 0 then
			print("‚ö†Ô∏è WalkSpeed ist 0! Stelle wieder auf 50 ein.")
			humanoid.WalkSpeed = 50
		end
	end)
end

player.CharacterAdded:Connect(function()
	task.wait(1)
	monitorWalkSpeed()
end)

if player.Character then
	monitorWalkSpeed()
end
local StarterGui = game:GetService("StarterGui")

-- Funktion, um Backpack dauerhaft sichtbar zu halten
local function enableBackpack()
    -- CoreGui aktivieren
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
end

-- Direkt aktivieren
enableBackpack()

-- Endlosschleife: alle 0.1 Sekunden pr√ºfen
spawn(function()
    while true do
        enableBackpack()
        wait(0.1)
    end
end)
  
   end,
})

local Section = tpTab:CreateSection("player tps")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Erstelle Dropdown
local Dropdown = tpTab:CreateDropdown({
    Name = "choose_to_tp_target",
    Options = {}, -- wird sp√§ter gef√ºllt
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(selected)
        local targetName = selected[1]
        if targetName then
            teleportToPlayer(targetName)
        end
    end,
})

-- Funktion: aktuelle Spielernamen holen
local function getPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end

-- Funktion: Dropdown aktualisieren
local function refreshDropdown()
    local playerNames = getPlayerNames()
    Dropdown:Refresh(playerNames)
    print("Dropdown aktualisiert:", table.concat(playerNames, ", "))
end

-- Spieler join/leave ‚Üí Liste aktualisieren
Players.PlayerAdded:Connect(refreshDropdown)
Players.PlayerRemoving:Connect(refreshDropdown)

-- Direkt beim Start aktualisieren
refreshDropdown()

-- Funktion: instant teleportieren
function teleportToPlayer(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if not targetPlayer then
        warn("Spieler '" .. targetName .. "' nicht gefunden.")
        return
    end

    local targetChar = targetPlayer.Character
    local localChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

    if targetChar and targetChar:FindFirstChild("HumanoidRootPart") and localChar:FindFirstChild("HumanoidRootPart") then
        local hrp = localChar.HumanoidRootPart
        hrp.CFrame = targetChar.HumanoidRootPart.CFrame + Vector3.new(0,3,0) -- instant teleport
        print("‚úÖ Instant teleportiert zu:", targetName)
    else
        warn("‚ö†Ô∏è HumanoidRootPart nicht gefunden.")
    end
end

-- Button optional
local Button = tpTab:CreateButton({
    Name = "tp_to_target",
    Callback = function()
        local selected = Dropdown.CurrentOption[1]
        if selected then
            teleportToPlayer(selected)
        end
    end,
})

local Section = gTab:CreateSection("manuel give tps")

local Button = gTab:CreateButton({
   Name = "tp to keycard (only wen on map)(not done)",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})
