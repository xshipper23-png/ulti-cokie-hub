local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "prison life",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "g", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local combatTab = Window:CreateTab("combat", nil) -- Title, Image
local PLTab = Window:CreateTab("player", nil) -- Title, Image
local tpTab = Window:CreateTab("teleport", nil) -- Title, Image
local stuffTab = Window:CreateTab("other stuff", nil) -- Title, Image

local Toggle = PLTab:CreateToggle({
   Name = "INFINIT JUMP",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(infijump)
-- GLOBAL BOOLEAN zur Steuerung
if _G.InfiniteJumpEnabled == nil then
    _G.InfiniteJumpEnabled = true -- erstes Mal starten ‚Üí aktiv
else
    _G.InfiniteJumpEnabled = not _G.InfiniteJumpEnabled -- beim erneuten Starten ‚Üí Toggle
end

print("[DEBUG] Infinite Jump Status:", _G.InfiniteJumpEnabled)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- Verbindung, die nur einmal erstellt wird
if not _G._InfiniteJumpConnection then
    _G._InfiniteJumpConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Space and _G.InfiniteJumpEnabled then
            local character = player.Character
            if not character then return end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "AIMBOT",
   CurrentValue = false,
   Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
  -- Aimbot Toggle Script
-- LocalScript (StarterPlayerScripts)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Toggle: beim ersten Start true, beim erneuten Start umkehren
if _G.AimBotEnabled == nil then
    _G.AimBotEnabled = true
else
    _G.AimBotEnabled = not _G.AimBotEnabled
end

print("[AIMBOT] Status:", _G.AimBotEnabled and "ON" or "OFF")

-- Einstellungen (kannst du anpassen)
local MAX_DISTANCE = 300      -- maximale Zielentfernung
local FOV_DEGREES = 80        -- Sichtfeld (gr√∂√üer = mehr Ziele)
local SMOOTHING = 0.35        -- 0 = instant, 1 = keine Bewegung (0..1), z.B. 0.35 = weich
local AIM_PART = "Head"       -- Zielteil am Gegner (z. B. "Head" oder "UpperTorso")

-- Hilfsfunktion: findet bestes Ziel
local function findBestTarget()
    if not camera or not localPlayer.Character then return nil end
    local camPos = camera.CFrame.Position
    local bestPlayer, bestPart, bestScore = nil, nil, -1
    local fovCos = math.cos(math.rad(FOV_DEGREES))

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character and pl.Character.Parent then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local part = pl.Character:FindFirstChild(AIM_PART) or pl.Character:FindFirstChild("HumanoidRootPart")
                if part and part:IsA("BasePart") then
                    local dir = (part.Position - camPos)
                    local dist = dir.Magnitude
                    if dist <= MAX_DISTANCE then
                        local dirUnit = dir.Unit
                        local forward = camera.CFrame.LookVector
                        local dot = forward:Dot(dirUnit)
                        if dot > fovCos then
                            -- Score kann Kombination aus dot (Ausrichtung) und inverse Distanz sein
                            local score = dot - (dist / (MAX_DISTANCE*2))
                            if score > bestScore then
                                bestScore = score
                                bestPlayer = pl
                                bestPart = part
                            end
                        end
                    end
                end
            end
        end
    end

    return bestPlayer, bestPart
end

-- Verbindung managen
if _G._AimBotConnection then
    -- Falls schon eine Verbindung existiert (aus vorherigem Lauf), trennen wir sie zuerst
    pcall(function() _G._AimBotConnection:Disconnect() end)
    _G._AimBotConnection = nil
end

if _G.AimBotEnabled then
    _G._AimBotConnection = RunService.RenderStepped:Connect(function()
        -- Sicherheitschecks
        if not camera then camera = workspace.CurrentCamera; if not camera then return end end
        if not localPlayer or not localPlayer.Character then return end

        local _, targetPart = findBestTarget()
        if targetPart then
            local camPos = camera.CFrame.Position
            local targetPos = targetPart.Position
            -- berechne gew√ºnschtes CFrame, das von Kamera-Position auf target schaut
            local desiredCFrame = CFrame.new(camPos, targetPos)
            -- Smooth Lerp der Kamera-Rotation (Position bleibt gleich)
            camera.CFrame = camera.CFrame:Lerp(desiredCFrame, SMOOTHING)
        end
    end)
else
    print("[AIMBOT] Deactivated, no connection left.")
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "ESP name ",
   CurrentValue = false,
   Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
-- ESP Name Toggle Script

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Toggle Status merken
if _G.ESPNameEnabled == nil then
    _G.ESPNameEnabled = true
else
    _G.ESPNameEnabled = not _G.ESPNameEnabled
end

print("[ESP NAME] Status:", _G.ESPNameEnabled and "ON" or "OFF")

-- Speicher f√ºr alle Nametags
_G._ESPNametags = _G._ESPNametags or {}

-- Nametag erstellen
local function createNametag(player)
    if player == localPlayer then return end
    if not player.Character then return end
    if _G._ESPNametags[player] and _G._ESPNametags[player].Parent then return end

    local head = player.Character:FindFirstChild("Head")
    if not head then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Name"
    billboard.Size = UDim2.new(0, 100, 0, 30)
    billboard.Adornee = head
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, 2, 0)

    local text = Instance.new("TextLabel", billboard)
    text.Size = UDim2.new(1, 0, 1, 0)
    text.Text = player.Name
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.fromRGB(255, 255, 255)
    text.TextStrokeTransparency = 0
    text.Font = Enum.Font.SourceSansBold
    text.TextScaled = true

    billboard.Parent = head
    _G._ESPNametags[player] = billboard
end

-- Nametag l√∂schen
local function removeNametag(player)
    if _G._ESPNametags[player] then
        _G._ESPNametags[player]:Destroy()
        _G._ESPNametags[player] = nil
    end
end

-- Aktivieren
if _G.ESPNameEnabled then
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer then
            createNametag(pl)
        end
    end

    if not _G._ESP_Name_PlayerAddedConn then
        _G._ESP_Name_PlayerAddedConn = Players.PlayerAdded:Connect(function(pl)
            pl.CharacterAdded:Connect(function()
                if _G.ESPNameEnabled then
                    createNametag(pl)
                end
            end)
        end)
    end

    print("[ESP NAME] Activated.")

-- Deaktivieren ‚Üí alles entfernen
else
    for _, pl in pairs(_G._ESPNametags) do
        if pl and pl.Parent then
            pl:Destroy()
        end
    end
    _G._ESPNametags = {}
    print("[ESP NAME] Deactivated and cleaned up.")
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "ESP BODY",
   CurrentValue = false,
   Flag = "e", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
  -- ESP Highlight Toggle Script

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Toggle Status merken
if _G.ESPHighlightEnabled == nil then
    _G.ESPHighlightEnabled = true
else
    _G.ESPHighlightEnabled = not _G.ESPHighlightEnabled
end

print("[ESP HIGHLIGHT] Status:", _G.ESPHighlightEnabled and "ON" or "OFF")

-- Speichert alle Highlights, damit wir sie entfernen k√∂nnen
_G._ESPHighlights = _G._ESPHighlights or {}

-- Funktion, die Highlight f√ºr einen Spieler erstellt
local function createHighlightForCharacter(player)
    if player == localPlayer then return end
    if not player.Character then return end
    if _G._ESPHighlights[player] and _G._ESPHighlights[player].Parent then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = player.Character
    highlight.FillColor = Color3.fromRGB(255, 50, 50) -- Rot (anpassbar)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- Wei√ü
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = player.Character

    _G._ESPHighlights[player] = highlight
end

-- Funktion, die Highlight entfernt
local function removeHighlightForPlayer(player)
    if _G._ESPHighlights[player] then
        _G._ESPHighlights[player]:Destroy()
        _G._ESPHighlights[player] = nil
    end
end

-- Wenn aktiv ‚Üí Highlights erstellen
if _G.ESPHighlightEnabled then
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character then
            createHighlightForCharacter(pl)
        end
    end

    -- Player joins
    if not _G._ESP_Highlight_PlayerAddedConn then
        _G._ESP_Highlight_PlayerAddedConn = Players.PlayerAdded:Connect(function(pl)
            pl.CharacterAdded:Connect(function()
                if _G.ESPHighlightEnabled then
                    createHighlightForCharacter(pl)
                end
            end)
        end)
    end

    -- Charakterwechsel f√ºr existierende Spieler
    if not _G._ESP_Highlight_CharAddedConn then
        _G._ESP_Highlight_CharAddedConn = {}
    end
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and not _G._ESP_Highlight_CharAddedConn[pl] then
            _G._ESP_Highlight_CharAddedConn[pl] = pl.CharacterAdded:Connect(function()
                if _G.ESPHighlightEnabled then
                    createHighlightForCharacter(pl)
                end
            end)
        end
    end

    print("[ESP HIGHLIGHT] Activated.")

-- Wenn deaktiviert ‚Üí alles aufr√§umen
else
    for _, pl in ipairs(Players:GetPlayers()) do
        removeHighlightForPlayer(pl)
    end
    print("[ESP HIGHLIGHT] Deactivated and cleaned up.")
end

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "speed",
   Range = {10, 300},
   Increment = 1,
   Suffix = " ",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(speed)
-- Optimiertes Live-Speed Script (kein Spam)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastSpeed -- merkt sich den alten Wert

-- Funktion: liest aktuellen speed-Wert
local function getSpeed()
    if typeof(speed) == "function" then
        return speed()
    elseif typeof(speed) == "Instance" and speed:IsA("NumberValue") then
        return speed.Value
    else
        return speed
    end
end

-- Funktion: setzt Geschwindigkeit nur wenn n√∂tig
local function applySpeed()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newSpeed = getSpeed()
    if newSpeed ~= lastSpeed then
        humanoid.WalkSpeed = newSpeed
        print("[SPEED] WalkSpeed ge√§ndert auf:", newSpeed)
        lastSpeed = newSpeed
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastSpeed = nil
    applySpeed()
end)

-- Wenn speed ein NumberValue ist ‚Üí live zuh√∂ren
if typeof(speed) == "Instance" and speed:IsA("NumberValue") then
    speed:GetPropertyChangedSignal("Value"):Connect(function()
        applySpeed()
    end)
end

-- Nur ca. 5x pro Sekunde pr√ºfen (schont CPU)
RunService.Stepped:Connect(function(_, step)
    applySpeed()
end)

-- Anfang
applySpeed()

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "jump BOST",
   Range = {0, 250},
   Increment = 10,
   Suffix = " ",
   CurrentValue = 25,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(jumpb)
  -- Optimiertes Live-Jump Script (Variable/Funktion/NumberValue "jumpb")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastJump -- merkt sich den alten Wert

-- Funktion: liest aktuellen jumpb-Wert
local function getJump()
    if typeof(jumpb) == "function" then
        return jumpb()
    elseif typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
        return jumpb.Value
    else
        return jumpb
    end
end

-- Funktion: setzt JumpPower nur wenn n√∂tig
local function applyJump()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newJump = getJump()
    if newJump ~= lastJump then
        humanoid.UseJumpPower = true -- sicherstellen, dass JumpPower benutzt wird
        humanoid.JumpPower = newJump
        print("[JUMP] JumpPower ge√§ndert auf:", newJump)
        lastJump = newJump
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastJump = nil
    applyJump()
end)

-- Wenn jumpb ein NumberValue ist ‚Üí live zuh√∂ren
if typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
    jumpb:GetPropertyChangedSignal("Value"):Connect(function()
        applyJump()
    end)
end

-- Alle paar Frames pr√ºfen (nicht spammen)
RunService.Stepped:Connect(function()
    applyJump()
end)

-- Anfang
applyJump()

   end,
})

local Section = combatTab:CreateSection("give weopens")

local Button = combatTab:CreateButton({
   Name = "get pistol",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(814, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = combatTab:CreateButton({
   Name = "get pump",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(821, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = combatTab:CreateButton({
   Name = "get AK-47",
   Callback = function()
  -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten und zur√ºck
-- ‚ö† Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gew√ºnschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-937, 94, 2050) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zur√ºck teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zur√ºck zur Ausgangsposition teleportiert.")
end

   end,
})

local Section = tpTab:CreateSection("in prison tps")

local Button = tpTab:CreateButton({
   Name = "roof",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(915, 150, 2286) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "weopen room police",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(848, 103, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Section = tpTab:CreateSection("open world tps ")

local Button = tpTab:CreateButton({
   Name = "prison front",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(484, 100, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "on prison wall",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(1050, 125, 2561) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "crim base",
   Callback = function()
   -- LocalScript ‚Äì Teleportiere dich zu festen Koordinaten (ohne R√ºck-Teleport)
-- F√ºge das Skript unter StarterPlayer ‚Üí StarterPlayerScripts ein.
-- ‚ö† Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-863, 98, 2108) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Toggle = PLTab:CreateToggle({
   Name = "NOCLIP",
   CurrentValue = false,
   Flag = "Togglefnopeclip", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
-- Noclip Script (Toggle on run)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local RunService = game:GetService("RunService")

-- Shared toggle state (global)
_G.noclip = not _G.noclip

if _G.noclip then
    print("Noclip ON")
    _G.noclipConnection = RunService.Stepped:Connect(function()
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
else
    print("Noclip OFF")
    if _G.noclipConnection then
        _G.noclipConnection:Disconnect()
        _G.noclipConnection = nil
    end
    -- Reset collisions
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "delet all doors(only client)",
   Callback = function()
   -- LocalScript: l√∂scht lokal alle Kinder eines Ordners namens "Doors" im Workspace
local RunService = game:GetService("RunService")

-- diese Abfrage stellt sicher, dass es CLIENT-SEITIG ist (LocalScript)
if not RunService:IsClient() then
    warn("Dieses Script ist f√ºr den Client gedacht.")
    return
end

local folder = workspace:FindFirstChild("Doors")
if not folder then
    warn("Ordner 'Doors' nicht gefunden im Workspace.")
    return
end

-- Sicherer L√∂schversuch
local success, err = pcall(function()
    -- ClearAllChildren l√∂scht alle Children; alternativ for-loop, wenn du mehr Kontrolle willst.
    folder:ClearAllChildren()
end)

if success then
    print("Alle Kinder von 'Doors' lokal entfernt.")
else
    warn("Fehler beim Entfernen: " .. tostring(err))
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "anti taser ()",
   Callback = function()
   -- LocalScript: Setzt WalkSpeed auf 50, wenn er auf 0 f√§llt
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function monitorWalkSpeed()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	print("üëü WalkSpeed-Monitor gestartet.")

	humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if humanoid.WalkSpeed == 0 then
			print("‚ö†Ô∏è WalkSpeed ist 0! Stelle wieder auf 50 ein.")
			humanoid.WalkSpeed = 50
		end
	end)
end

player.CharacterAdded:Connect(function()
	task.wait(1)
	monitorWalkSpeed()
end)

if player.Character then
	monitorWalkSpeed()
end
local StarterGui = game:GetService("StarterGui")

-- Funktion, um Backpack dauerhaft sichtbar zu halten
local function enableBackpack()
    -- CoreGui aktivieren
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
end

-- Direkt aktivieren
enableBackpack()

-- Endlosschleife: alle 0.1 Sekunden pr√ºfen
spawn(function()
    while true do
        enableBackpack()
        wait(0.1)
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Liste der Standard-AnimationsIDs von Roblox (Idle, Run, Walk, Jump, etc.)
local standardAnimationIds = {
    ["rbxassetid://180435571"] = true, -- idle
    ["rbxassetid://180426354"] = true, -- walk
    ["rbxassetid://180436148"] = true, -- run
    ["rbxassetid://180433900"] = true, -- jump
    ["rbxassetid://180436334"] = true, -- fall
}

-- Funktion, um Custom-Animationen zu stoppen
local function stopCustomAnimations(humanoid)
    if not humanoid then return end

    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
        if track.Animation then
            local id = "rbxassetid://"..track.Animation.AnimationId:match("%d+")
            if not standardAnimationIds[id] then
                track:Stop()
            end
        end
    end
end

-- √úberwacht einen Spieler
local function monitorPlayer(player)
    player.CharacterAdded:Connect(function(char)
        local humanoid = char:WaitForChild("Humanoid")
        -- Schleife, um kontinuierlich neue Tracks zu pr√ºfen
        spawn(function()
            while humanoid.Parent do
                stopCustomAnimations(humanoid)
                wait(0.1)
            end
        end)
    end)

    -- Falls Character schon existiert
    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            spawn(function()
                while humanoid.Parent do
                    stopCustomAnimations(humanoid)
                    wait(0.1)
                end
            end)
        end
    end
end

-- Alle Spieler √ºberwachen
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        monitorPlayer(player)
    end
end

-- Neue Spieler automatisch √ºberwachen
Players.PlayerAdded:Connect(monitorPlayer)

            
   end,
})

local Section = tpTab:CreateSection("player tps")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Erstelle Dropdown
local Dropdown = tpTab:CreateDropdown({
    Name = "choose_to_tp_target",
    Options = {}, -- wird sp√§ter gef√ºllt
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(selected)
        local targetName = selected[1]
        if targetName then
            teleportToPlayer(targetName)
        end
    end,
})

-- Funktion: aktuelle Spielernamen holen
local function getPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end

-- Funktion: Dropdown aktualisieren
local function refreshDropdown()
    local playerNames = getPlayerNames()
    Dropdown:Refresh(playerNames)
    print("Dropdown aktualisiert:", table.concat(playerNames, ", "))
end

-- Spieler join/leave ‚Üí Liste aktualisieren
Players.PlayerAdded:Connect(refreshDropdown)
Players.PlayerRemoving:Connect(refreshDropdown)

-- Direkt beim Start aktualisieren
refreshDropdown()

-- Funktion: instant teleportieren
function teleportToPlayer(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if not targetPlayer then
        warn("Spieler '" .. targetName .. "' nicht gefunden.")
        return
    end

    local targetChar = targetPlayer.Character
    local localChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

    if targetChar and targetChar:FindFirstChild("HumanoidRootPart") and localChar:FindFirstChild("HumanoidRootPart") then
        local hrp = localChar.HumanoidRootPart
        hrp.CFrame = targetChar.HumanoidRootPart.CFrame + Vector3.new(0,3,0) -- instant teleport
        print("‚úÖ Instant teleportiert zu:", targetName)
    else
        warn("‚ö†Ô∏è HumanoidRootPart nicht gefunden.")
    end
end

-- Button optional
local Button = tpTab:CreateButton({
    Name = "tp_to_target",
    Callback = function()
        local selected = Dropdown.CurrentOption[1]
        if selected then
            teleportToPlayer(selected)
        end
    end,
})

local Section = combatTab:CreateSection("auto kill")

local Button = combatTab:CreateButton({
   Name = "kill all gui",
   Callback = function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/ShutUpJamesTheLoserAlt/PrisonLife/refs/heads/main/Killall"))()
   end
})

