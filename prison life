local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "prison life",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "g", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local combatTab = Window:CreateTab("combat", nil) -- Title, Image
local PLTab = Window:CreateTab("player", nil) -- Title, Image
local tpTab = Window:CreateTab("teleport", nil) -- Title, Image
local stuffTab = Window:CreateTab("other stuff", nil) -- Title, Image
local gTab = Window:CreateTab("give", nil) -- Title, Image
local upTab = Window:CreateTab("updates", nil) -- Title, Image

local Label = upTab:CreateLabel("last update:new aimbot/give/tp", nil, Color3.fromRGB(255, 255, 255), false) -- Title, Icon, Color,

local Toggle = PLTab:CreateToggle({
   Name = "INFINIT JUMP",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(infijump)
-- GLOBAL BOOLEAN zur Steuerung
if _G.InfiniteJumpEnabled == nil then
    _G.InfiniteJumpEnabled = true -- erstes Mal starten → aktiv
else
    _G.InfiniteJumpEnabled = not _G.InfiniteJumpEnabled -- beim erneuten Starten → Toggle
end

print("[DEBUG] Infinite Jump Status:", _G.InfiniteJumpEnabled)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- Verbindung, die nur einmal erstellt wird
if not _G._InfiniteJumpConnection then
    _G._InfiniteJumpConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Space and _G.InfiniteJumpEnabled then
            local character = player.Character
            if not character then return end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "AIMBOT",
   CurrentValue = false,
   Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
  -- Aimbot Toggle Script
-- LocalScript (StarterPlayerScripts)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Toggle: beim ersten Start true, beim erneuten Start umkehren
if _G.AimBotEnabled == nil then
    _G.AimBotEnabled = true
else
    _G.AimBotEnabled = not _G.AimBotEnabled
end

print("[AIMBOT] Status:", _G.AimBotEnabled and "ON" or "OFF")

-- Einstellungen (kannst du anpassen)
local MAX_DISTANCE = 300      -- maximale Zielentfernung
local FOV_DEGREES = 80        -- Sichtfeld (größer = mehr Ziele)
local SMOOTHING = 0.35        -- 0 = instant, 1 = keine Bewegung (0..1), z.B. 0.35 = weich
local AIM_PART = "Head"       -- Zielteil am Gegner (z. B. "Head" oder "UpperTorso")

-- Hilfsfunktion: findet bestes Ziel
local function findBestTarget()
    if not camera or not localPlayer.Character then return nil end
    local camPos = camera.CFrame.Position
    local bestPlayer, bestPart, bestScore = nil, nil, -1
    local fovCos = math.cos(math.rad(FOV_DEGREES))

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character and pl.Character.Parent then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local part = pl.Character:FindFirstChild(AIM_PART) or pl.Character:FindFirstChild("HumanoidRootPart")
                if part and part:IsA("BasePart") then
                    local dir = (part.Position - camPos)
                    local dist = dir.Magnitude
                    if dist <= MAX_DISTANCE then
                        local dirUnit = dir.Unit
                        local forward = camera.CFrame.LookVector
                        local dot = forward:Dot(dirUnit)
                        if dot > fovCos then
                            -- Score kann Kombination aus dot (Ausrichtung) und inverse Distanz sein
                            local score = dot - (dist / (MAX_DISTANCE*2))
                            if score > bestScore then
                                bestScore = score
                                bestPlayer = pl
                                bestPart = part
                            end
                        end
                    end
                end
            end
        end
    end

    return bestPlayer, bestPart
end

-- Verbindung managen
if _G._AimBotConnection then
    -- Falls schon eine Verbindung existiert (aus vorherigem Lauf), trennen wir sie zuerst
    pcall(function() _G._AimBotConnection:Disconnect() end)
    _G._AimBotConnection = nil
end

if _G.AimBotEnabled then
    _G._AimBotConnection = RunService.RenderStepped:Connect(function()
        -- Sicherheitschecks
        if not camera then camera = workspace.CurrentCamera; if not camera then return end end
        if not localPlayer or not localPlayer.Character then return end

        local _, targetPart = findBestTarget()
        if targetPart then
            local camPos = camera.CFrame.Position
            local targetPos = targetPart.Position
            -- berechne gewünschtes CFrame, das von Kamera-Position auf target schaut
            local desiredCFrame = CFrame.new(camPos, targetPos)
            -- Smooth Lerp der Kamera-Rotation (Position bleibt gleich)
            camera.CFrame = camera.CFrame:Lerp(desiredCFrame, SMOOTHING)
        end
    end)
else
    print("[AIMBOT] Deactivated, no connection left.")
end

   end,
})

local Toggle = combatTab:CreateToggle({
   Name = "ESP",
   CurrentValue = false,
   Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(e)
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

local function createDisplay(player)
	if player == LocalPlayer then return end

	local function attachToCharacter(character)
		local head = character:WaitForChild("Head", 5)
		if not head then return end

		local billboard = Instance.new("BillboardGui")
		billboard.Name = "TeamESP_Display"
		billboard.AlwaysOnTop = true
		billboard.Size = UDim2.new(4, 0, 1, 0)
		billboard.StudsOffset = Vector3.new(0, 3, 0)
		billboard.MaxDistance = 500
		billboard.Parent = head

		local nameLabel = Instance.new("TextLabel")
		nameLabel.BackgroundTransparency = 1
		nameLabel.Size = UDim2.new(0.75, 0, 0.4, 0)
		nameLabel.Position = UDim2.new(0, 0, 0, 0)
		nameLabel.Text = player.DisplayName
		nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		nameLabel.TextStrokeTransparency = 0
		nameLabel.Font = Enum.Font.SourceSansBold
		nameLabel.TextScaled = true
		nameLabel.Parent = billboard

		local teamBox = Instance.new("Frame")
		teamBox.Size = UDim2.new(0.2, 0, 0.4, 0)
		teamBox.Position = UDim2.new(0.78, 0, 0, 0)
		teamBox.BorderSizePixel = 0
		teamBox.BackgroundColor3 = player.TeamColor and player.TeamColor.Color or Color3.new(1, 1, 1)
		teamBox.Parent = billboard

		local bg = Instance.new("Frame")
		bg.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		bg.BorderSizePixel = 0
		bg.Position = UDim2.new(0.1, 0, 0.55, 0)
		bg.Size = UDim2.new(0.8, 0, 0.2, 0)
		bg.Parent = billboard

		local fill = Instance.new("Frame")
		fill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
		fill.BorderSizePixel = 0
		fill.Size = UDim2.new(1, 0, 1, 0)
		fill.Parent = bg

		local percentLabel = Instance.new("TextLabel")
		percentLabel.BackgroundTransparency = 1
		percentLabel.Size = UDim2.new(1, 0, 1, 0)
		percentLabel.Position = UDim2.new(0, 0, 0, 0)
		percentLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		percentLabel.TextStrokeTransparency = 0
		percentLabel.Font = Enum.Font.SourceSansBold
		percentLabel.TextScaled = true
		percentLabel.Parent = bg

		local highlight = Instance.new("Highlight")
		highlight.Name = "TeamHighlight"
		highlight.Adornee = character
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0.1
		highlight.FillColor = player.TeamColor and player.TeamColor.Color or Color3.new(1,1,1)
		highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
		highlight.Parent = character

		player:GetPropertyChangedSignal("TeamColor"):Connect(function()
			teamBox.BackgroundColor3 = player.TeamColor.Color
			highlight.FillColor = player.TeamColor.Color
		end)

		local function updateHealth(humanoid)
			local function refresh()
				local ratio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
				fill.Size = UDim2.new(ratio, 0, 1, 0)
				if ratio > 0.5 then
					fill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
				elseif ratio > 0.25 then
					fill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
				else
					fill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
				end
				percentLabel.Text = math.floor(ratio * 100) .. "%"
			end
			refresh()
			humanoid.HealthChanged:Connect(refresh)
		end

		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then updateHealth(humanoid) end
		character.ChildAdded:Connect(function(child)
			if child:IsA("Humanoid") then updateHealth(child) end
		end)

		-- === Dynamische Skalierung (stärker) ===
		RunService.RenderStepped:Connect(function()
			if head and head.Parent then
				local dist = (Camera.CFrame.Position - head.Position).Magnitude
				local scale = math.clamp((dist / 50) * 2, 1, 8) -- Faktor x2, max 8x
				billboard.Size = UDim2.new(4 * scale, 0, 1 * scale, 0)
			end
		end)
	end

	if player.Character then attachToCharacter(player.Character) end
	player.CharacterAdded:Connect(attachToCharacter)
end

for _, plr in pairs(Players:GetPlayers()) do createDisplay(plr) end
Players.PlayerAdded:Connect(createDisplay)

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "speed",
   Range = {10, 300},
   Increment = 1,
   Suffix = " ",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(speed)
-- Optimiertes Live-Speed Script (kein Spam)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastSpeed -- merkt sich den alten Wert

-- Funktion: liest aktuellen speed-Wert
local function getSpeed()
    if typeof(speed) == "function" then
        return speed()
    elseif typeof(speed) == "Instance" and speed:IsA("NumberValue") then
        return speed.Value
    else
        return speed
    end
end

-- Funktion: setzt Geschwindigkeit nur wenn nötig
local function applySpeed()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newSpeed = getSpeed()
    if newSpeed ~= lastSpeed then
        humanoid.WalkSpeed = newSpeed
        print("[SPEED] WalkSpeed geändert auf:", newSpeed)
        lastSpeed = newSpeed
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastSpeed = nil
    applySpeed()
end)

-- Wenn speed ein NumberValue ist → live zuhören
if typeof(speed) == "Instance" and speed:IsA("NumberValue") then
    speed:GetPropertyChangedSignal("Value"):Connect(function()
        applySpeed()
    end)
end

-- Nur ca. 5x pro Sekunde prüfen (schont CPU)
RunService.Stepped:Connect(function(_, step)
    applySpeed()
end)

-- Anfang
applySpeed()

   end,
})

local Slider = PLTab:CreateSlider({
   Name = "jump BOST",
   Range = {0, 250},
   Increment = 10,
   Suffix = " ",
   CurrentValue = 25,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(jumpb)
  -- Optimiertes Live-Jump Script (Variable/Funktion/NumberValue "jumpb")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastJump -- merkt sich den alten Wert

-- Funktion: liest aktuellen jumpb-Wert
local function getJump()
    if typeof(jumpb) == "function" then
        return jumpb()
    elseif typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
        return jumpb.Value
    else
        return jumpb
    end
end

-- Funktion: setzt JumpPower nur wenn nötig
local function applyJump()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local newJump = getJump()
    if newJump ~= lastJump then
        humanoid.UseJumpPower = true -- sicherstellen, dass JumpPower benutzt wird
        humanoid.JumpPower = newJump
        print("[JUMP] JumpPower geändert auf:", newJump)
        lastJump = newJump
    end
end

-- Beim Respawn neu setzen
player.CharacterAdded:Connect(function()
    player.Character:WaitForChild("Humanoid")
    lastJump = nil
    applyJump()
end)

-- Wenn jumpb ein NumberValue ist → live zuhören
if typeof(jumpb) == "Instance" and jumpb:IsA("NumberValue") then
    jumpb:GetPropertyChangedSignal("Value"):Connect(function()
        applyJump()
    end)
end

-- Alle paar Frames prüfen (nicht spammen)
RunService.Stepped:Connect(function()
    applyJump()
end)

-- Anfang
applyJump()

   end,
})

local Section = gTab:CreateSection("give weopens")

local Button = gTab:CreateButton({
   Name = "get pistol",
   Callback = function()
  -- LocalScript – Teleportiere dich zu festen Koordinaten und zurück
-- ⚠ Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gewünschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(814, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zurück teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zurück zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = gTab:CreateButton({
   Name = "get pump",
   Callback = function()
  -- LocalScript – Teleportiere dich zu festen Koordinaten und zurück
-- ⚠ Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gewünschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(821, 101, 2217) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zurück teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zurück zur Ausgangsposition teleportiert.")
end

   end,
})

local Button = gTab:CreateButton({
   Name = "get AK-47",
   Callback = function()
  -- LocalScript – Teleportiere dich zu festen Koordinaten und zurück
-- ⚠ Nur clientseitig (funktioniert in Studio oder LocalSimulation)
-- Ersetze die Werte in TARGET durch deine gewünschten Koordinaten.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-922, 94, 2051) -- <--- DEINE KOORDINATEN
-- ==============================================

-- Position merken, wo Skript gestartet wurde
local originalCFrame = hrp.CFrame

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)
print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

-- 1.5 Sekunden warten
task.wait(0.5)

-- Zurück teleportieren
if hrp and hrp.Parent then
	hrp.CFrame = originalCFrame
	print("Zurück zur Ausgangsposition teleportiert.")
end

   end,
})

local Section = tpTab:CreateSection("in prison tps")

local Button = tpTab:CreateButton({
   Name = "roof",
   Callback = function()
   -- LocalScript – Teleportiere dich zu festen Koordinaten (ohne Rück-Teleport)
-- Füge das Skript unter StarterPlayer → StarterPlayerScripts ein.
-- ⚠ Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(915, 150, 2286) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "weopen room police",
   Callback = function()
   -- LocalScript – Teleportiere dich zu festen Koordinaten (ohne Rück-Teleport)
-- Füge das Skript unter StarterPlayer → StarterPlayerScripts ein.
-- ⚠ Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(848, 103, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Section = tpTab:CreateSection("open world tps ")

local Button = tpTab:CreateButton({
   Name = "prison front",
   Callback = function()
   -- LocalScript – Teleportiere dich zu festen Koordinaten (ohne Rück-Teleport)
-- Füge das Skript unter StarterPlayer → StarterPlayerScripts ein.
-- ⚠ Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(484, 100, 2244) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "on prison wall",
   Callback = function()
   -- LocalScript – Teleportiere dich zu festen Koordinaten (ohne Rück-Teleport)
-- Füge das Skript unter StarterPlayer → StarterPlayerScripts ein.
-- ⚠ Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(1050, 125, 2561) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Button = tpTab:CreateButton({
   Name = "crim base",
   Callback = function()
   -- LocalScript – Teleportiere dich zu festen Koordinaten (ohne Rück-Teleport)
-- Füge das Skript unter StarterPlayer → StarterPlayerScripts ein.
-- ⚠ Nur clientseitig, funktioniert im Play-Test in Roblox Studio.

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- === HIER DEINE ZIEL-KOORDINATEN EINTRAGEN ===
local TARGET = Vector3.new(-863, 98, 2108) -- <--- DEINE KOORDINATEN HIER
-- ==============================================

-- Teleportiere zum Ziel
hrp.CFrame = CFrame.new(TARGET)

print(string.format("Teleportiert zu: X=%.1f, Y=%.1f, Z=%.1f", TARGET.X, TARGET.Y, TARGET.Z))

   end,
})

local Toggle = PLTab:CreateToggle({
   Name = "NOCLIP",
   CurrentValue = false,
   Flag = "Togglefnopeclip", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
-- Noclip Script (Toggle on run)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local RunService = game:GetService("RunService")

-- Shared toggle state (global)
_G.noclip = not _G.noclip

if _G.noclip then
    print("Noclip ON")
    _G.noclipConnection = RunService.Stepped:Connect(function()
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
else
    print("Noclip OFF")
    if _G.noclipConnection then
        _G.noclipConnection:Disconnect()
        _G.noclipConnection = nil
    end
    -- Reset collisions
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "delet all doors(only client)",
   Callback = function()
   -- LocalScript: löscht lokal alle Kinder eines Ordners namens "Doors" im Workspace
local RunService = game:GetService("RunService")

-- diese Abfrage stellt sicher, dass es CLIENT-SEITIG ist (LocalScript)
if not RunService:IsClient() then
    warn("Dieses Script ist für den Client gedacht.")
    return
end

local folder = workspace:FindFirstChild("Doors")
if not folder then
    warn("Ordner 'Doors' nicht gefunden im Workspace.")
    return
end

-- Sicherer Löschversuch
local success, err = pcall(function()
    -- ClearAllChildren löscht alle Children; alternativ for-loop, wenn du mehr Kontrolle willst.
    folder:ClearAllChildren()
end)

if success then
    print("Alle Kinder von 'Doors' lokal entfernt.")
else
    warn("Fehler beim Entfernen: " .. tostring(err))
end

   end,
})

local Button = stuffTab:CreateButton({
   Name = "anti taser ()",
   Callback = function()
   -- LocalScript: Setzt WalkSpeed auf 50, wenn er auf 0 fällt
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function monitorWalkSpeed()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")

	print("👟 WalkSpeed-Monitor gestartet.")

	humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if humanoid.WalkSpeed == 0 then
			print("⚠️ WalkSpeed ist 0! Stelle wieder auf 50 ein.")
			humanoid.WalkSpeed = 50
		end
	end)
end

player.CharacterAdded:Connect(function()
	task.wait(1)
	monitorWalkSpeed()
end)

if player.Character then
	monitorWalkSpeed()
end
local StarterGui = game:GetService("StarterGui")

-- Funktion, um Backpack dauerhaft sichtbar zu halten
local function enableBackpack()
    -- CoreGui aktivieren
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
end

-- Direkt aktivieren
enableBackpack()

-- Endlosschleife: alle 0.1 Sekunden prüfen
spawn(function()
    while true do
        enableBackpack()
        wait(0.1)
    end
end)
  
   end,
})

local Section = tpTab:CreateSection("player tps")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Erstelle Dropdown
local Dropdown = tpTab:CreateDropdown({
    Name = "choose_to_tp_target",
    Options = {}, -- wird später gefüllt
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(selected)
        local targetName = selected[1]
        if targetName then
            teleportToPlayer(targetName)
        end
    end,
})

-- Funktion: aktuelle Spielernamen holen
local function getPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end

-- Funktion: Dropdown aktualisieren
local function refreshDropdown()
    local playerNames = getPlayerNames()
    Dropdown:Refresh(playerNames)
    print("Dropdown aktualisiert:", table.concat(playerNames, ", "))
end

-- Spieler join/leave → Liste aktualisieren
Players.PlayerAdded:Connect(refreshDropdown)
Players.PlayerRemoving:Connect(refreshDropdown)

-- Direkt beim Start aktualisieren
refreshDropdown()

-- Funktion: instant teleportieren
function teleportToPlayer(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if not targetPlayer then
        warn("Spieler '" .. targetName .. "' nicht gefunden.")
        return
    end

    local targetChar = targetPlayer.Character
    local localChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

    if targetChar and targetChar:FindFirstChild("HumanoidRootPart") and localChar:FindFirstChild("HumanoidRootPart") then
        local hrp = localChar.HumanoidRootPart
        hrp.CFrame = targetChar.HumanoidRootPart.CFrame + Vector3.new(0,3,0) -- instant teleport
        print("✅ Instant teleportiert zu:", targetName)
    else
        warn("⚠️ HumanoidRootPart nicht gefunden.")
    end
end

-- Button optional
local Button = tpTab:CreateButton({
    Name = "tp_to_target",
    Callback = function()
        local selected = Dropdown.CurrentOption[1]
        if selected then
            teleportToPlayer(selected)
        end
    end,
})

local Section = gTab:CreateSection("manuel give tps")

local Button = gTab:CreateButton({
   Name = "tp to keycard (only wen on map)(not done)",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})
